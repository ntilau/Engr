close all;
clear all;


%% load unreduced model
tic
disp(' ')
disp('Loading raw model...');

geoModelName = 'C:\work\examples\bandpassfilter\bandpass2\bandpass2_1.1e+009_5_geo\';
fNameAll = strcat(geoModelName, 'bandpassAfterTest_6_6_6_tsch.mat');
fNameAllData = load(fNameAll);

modelName = geoModelName;

% read "modelParam.txt"
fNameModRedTxt = strcat(geoModelName, 'modelParam.txt');
[f0, paramNames, paramValInExp, numLeftVecs, abcFlag] = ...
  readModParaTxt(fNameModRedTxt);
useKrylovSpaces = vectorReader(strcat(geoModelName, 'useKrylovSpaces.txt'));

order = 5;
numLeftVecs = 2;
linFreqParamFlag = true;
c0 = 299792.458e3;
k0 = 2*pi*f0/c0;

% construct matrix with the ordering of the coefficients
permutMat = [];
maxOrder = length(fNameAllData.sIntPnts{1}) + length(fNameAllData.sIntPnts{2}) ...
  + length(fNameAllData.sIntPnts{3}) - 3 + 1;
numParams = 4;
for k = 0:maxOrder
  permutMat = rec(numParams, k, permutMat, 0, 1);
end

toc

%% Build parameter dependend unreduced model
tic
disp(' ')
disp('Building parameter dependend unreduced model...');

sysMat = cell(size(permutMat, 1), 1);
if linFreqParamFlag
  for matCnt = 1:length(fNameAllData.parMat)
%     if ~isempty(parMat{matCnt})
    if nnz(fNameAllData.parMat{matCnt})
      row = [0 fNameAllData.finalPoly(matCnt,:)];
      pos = findRowInMat(row, permutMat);
      sysMat{pos} = fNameAllData.parMat{matCnt};
    end
  end
  for matCnt = 1:length(fNameAllData.parMatK2)
%     if ~isempty(parMatK2{matCnt})
    if nnz(fNameAllData.parMatK2{matCnt})
      row = [1 fNameAllData.finalPoly(matCnt,:)];
      pos = findRowInMat(row, permutMat);
      sysMat{pos} = -k0^2 * fNameAllData.parMatK2{matCnt};
    end
  end
else
  error('Should not happen!');
end

rhs = cell(numLeftVecs, 1);
for k = 1:numLeftVecs
  rhs{k} = vectorReader(strcat(modelName, 'rhs', num2str(k-1))); 
end

clear fNameAllData;
toc

%% Build reduced order model
tic
disp(' ')
disp('Building reduced order model...');

% system matrix in expansion point
% ABC are already included in sys0 if present
[fact.L, fact.U, fact.P, fact.Q] = lu(sysMat{1});

sol = cell(numLeftVecs, 1);
for k = 1:numLeftVecs
  sol{k} = fact.Q*(fact.U\(fact.L\(fact.P*rhs{k})));
end

K = computeProjectionSpaceInterp(numParams, order, sysMat, fact, sol, permutMat, useKrylovSpaces);

% tic;
% interpolPnts = calcInterpolPnts(numParams, order);
% numVectorsTotal = 0;
% for orderCnt = 0 : order
%   numInterpolPntsOrder = nchoosek(orderCnt + numParams - 1, orderCnt);
%   numVectorsTotal = numVectorsTotal + numInterpolPntsOrder;
% end
% numVectorsTotal = numVectorsTotal * length(useKrylovSpaces);
% disp(['Dimension of ROM: ' num2str(numVectorsTotal)]);
% K = [];
% normNewDirection = [];
% % K = compGenKrySpaceNparamPoly(sysMat, fact, sol{1}, order, numParams);  % space for S11
% for k = 1:length(useKrylovSpaces)
%   %   [Q H] = Arnoldi(fact, sysMat{2}, sol{useKrylovSpaces(k)+1}, order);
%   if numParams == 1
%     oneParamModel = createOneParamModel(sysMat, permutMat, ...
%       interpolPnts{order});
%     [Q H] = wcawe(fact, oneParamModel, sol{useKrylovSpaces(k)+1}, ...
%       order);
%     if isempty(K)
%       K = Q;
%     else
%       for colCnt = 1:size(Q, 2)
%         % modified Gram Schmidt
%         for kColCnt = 1:size(K, 2)
%           proj = K(:, kColCnt)' * Q(:, colCnt);
%           Q(:, colCnt) = Q(:, colCnt) - proj * K(:, kColCnt);
%         end
%         normNewDirection = [normNewDirection norm(Q(:, colCnt))];
%         K = [K, (Q(:, colCnt) / norm(Q(:, colCnt)))];
%       end
%     end
%   else
%     % several parameters
%     for orderCnt = 1:length(interpolPnts)
%       for pntCnt = 1:size(interpolPnts{orderCnt}, 1);
%         oneParamModel = createOneParamModel(sysMat, permutMat, ...
%           interpolPnts{orderCnt}(pntCnt,:));
%         %       [Q H] = wcawe(fact, oneParamModel, sol{useKrylovSpaces(k)+1}, ...
%         %         order);
%         [Q H] = wcawe(fact, oneParamModel, sol{useKrylovSpaces(k)+1}, ...
%           order);
%         if isempty(K)
%           K = Q;
%         else
%           for colCnt = 1:size(Q, 2)
%             if colCnt >= orderCnt
%               % modified Gram Schmidt
%               for kColCnt = 1:size(K, 2)
%                 proj = K(:, kColCnt)' * Q(:, colCnt);
%                 Q(:, colCnt) = Q(:, colCnt) - proj * K(:, kColCnt);
%               end
%               normNewDirection = [normNewDirection norm(Q(:, colCnt))];
%               K = [K, (Q(:, colCnt) / norm(Q(:, colCnt)))];
%             end
%           end
%         end
%       end
%     end
%   end
% end
% toc;

t1 = toc;
disp(' ')
disp('Time for computing projection space: ');
disp(t1);

clear fact;

Q = K;
% [Q, R] = qr(K);
clear K;

% compute projections onto space K
sysMatRed = cell(length(sysMat), 1);
for k = 1:length(sysMat)
  if ~isempty(sysMat{k})
    sysMatRed{k} = Q.'*sysMat{k}*Q;
    clear sysMat{k};
  end
end

lVecRed = cell(numLeftVecs, 1);
redRhs = cell(numLeftVecs, 1);
for k = 1:numLeftVecs
  lVec = vectorReader(strcat(modelName, 'leftVec', num2str(k-1)));
  lVecRed{k} = lVec.'*Q;
  % computation of Krylov space is done in real arithmetic
  rhs{k} = -2*j*rhs{k};   
  redRhs{k} = Q.'*rhs{k};
end

t2 = toc;
disp(' ')
disp('Time for projecting model: ');
disp(t2 - t1);

toc

%% Save reduced model
tic
disp(' ')
disp('Saving reduced order model...');

colCntPermutMat = size(permutMat, 2);
nonempty = 0;
for k = 1:length(sysMatRed)
  if ~isempty(sysMatRed{k})
    nonempty = nonempty + 1;
  end
end
sysMatCleared = zeros(nonempty, size(permutMat, 2));
nonemptyCnt = 1;
for k = 1:length(sysMatRed)
  if ~isempty(sysMatRed{k})
    fName = strcat(modelName, 'sysMatRed_', num2str(permutMat(k, 1)));
    for m = 2:colCntPermutMat
      fName = strcat(fName, '_', num2str(permutMat(k, m)));
    end
    writeMatFull(sysMatRed{k}, fName);
    sysMatCleared(nonemptyCnt, :) = permutMat(k,:);
    nonemptyCnt = nonemptyCnt + 1;
  end
end

save(strcat(modelName, 'sysMatRed'), )

writeSysMatRedNames(sysMatCleared, strcat(modelName, 'sysMatRedNames'));

for k = 1:numLeftVecs
  writeVector(lVecRed{k}, strcat(modelName, 'leftVecsRed', num2str(k-1)));
  writeVector(redRhs{k}, strcat(modelName, 'redRhs', num2str(k-1)));
end
toc
