% This script tests the properties of Tschebyscheff Approximation
% close all;
clear all;

set(0,'DefaultFigureWindowStyle','docked');

% function defined on interval [a,b]
a1 = -2;
b1 = +2;
a2 = -4;
b2 = +4;
func = @(x, y) (sin(x) * cos(y));

% number of interpolation points
n1 = 8;
n2 = 8;
dimLow = 4;

% take arbitrary interval into accout, not only [-1,1]
bma1 = 0.5 * (b1 - a1);
bpa1 = 0.5 * (b1 + a1);
bma2 = 0.5 * (b2 - a2);
bpa2 = 0.5 * (b2 + a2);

% evalute the function at the zeros of the n-th Tschebyscheff polynomial
y1 = cos(pi * ((1:n1) - 0.5) / n1);
y2 = cos(pi * ((1:n2) - 0.5) / n2);
f = cell(n1, n2);
for y2Cnt = 1:length(y2)
  for y1Cnt = 1:length(y1)
    f{y1Cnt, y2Cnt} = func(y1(y1Cnt) * bma1 + bpa1, ...
      y2(y2Cnt) * bma2 + bpa2);
  end
end

% compute coefficent matrix c of the Tschebyscheff polynomials
c = tschebyCoeff2dCell(f);

x1 = a1:0.1:b1;
x2 = a2:0.1:b2;

% back conversion into polynomials 1, x, y, x^2, ....
% order (first x then y or vice versa) in wich backConvertTscheby 
% is called doesn't make a difference
d = backConvertTscheby2dCell(a1, b1, a2, b2, c);
display(d);

finalPoly = [];
maxOrder = n1 + n2 - 2;
numParams = 2;
for k = 0:maxOrder
  finalPoly = rec(numParams, k, finalPoly, 0, 1);
end
coeffPoly = zeros(size(finalPoly, 1), length(f{1, 1}));

for x1Cnt = 1:n1
  for x2Cnt = 1:n2
    rowNow = [(x1Cnt - 1) (x2Cnt - 1)]; 
    rowPos = findRowInMat(rowNow, finalPoly);
    coeffPoly(rowPos, :) = d{x1Cnt, x2Cnt};
  end
end

fTest = zeros(length(x1), length(x2));
for s1Cnt = 1:length(x1)
  for s2Cnt = 1:length(x2)
    sAct = [x1(s1Cnt) x2(s2Cnt)];
    fNow = 0;
    for rowCnt = 1:size(finalPoly, 1)
      pow = 1;
      for parCnt = 1:size(finalPoly, 2)
        pow = pow * sAct(parCnt)^finalPoly(rowCnt, parCnt);
      end
      fNow = fNow + coeffPoly(rowCnt, :) .* pow ;
    end
    fTest(s1Cnt, s2Cnt) = fNow;
  end
end

% plot functions
fRes = zeros(length(x1), length(x2));
for x2Cnt = 1:length(x2)
  for x1Cnt = 1:length(x1)
    fRes(x1Cnt, x2Cnt) = func(x1(x1Cnt), x2(x2Cnt));
  end
end

figure;
surf(x2, x1, fRes);
figure;
surf(x2, x1, fTest);
% axis([a1 b1 a2 b2 -1 1]);

% plot magnitude of error
figure;
surf(x2, x1, abs(fRes - fTest));

% approximation of lower order
c2Low = cell(dimLow, dimLow);
for rowCnt = 1:dimLow
  for colCnt = 1:dimLow
    c2Low{rowCnt, colCnt} = c{rowCnt, colCnt};
  end
end

% back conversion into polynomials 1, x, y, x^2, ....
% order (first x then y or vice versa) in wich backConvertTscheby 
% is called doesn't make a difference
dLow = backConvertTscheby2dCell(a1, b1, a2, b2, c);
display(d);

finalPoly = [];
maxOrder = n1 + n2 - 2;
numParams = 2;
for k = 0:maxOrder
  finalPoly = rec(numParams, k, finalPoly, 0, 1);
end
coeffPoly = zeros(size(finalPoly, 1), length(f{1, 1}));

for x1Cnt = 1:n1
  for x2Cnt = 1:n2
    rowNow = [(x1Cnt - 1) (x2Cnt - 1)]; 
    rowPos = findRowInMat(rowNow, finalPoly);
    coeffPoly(rowPos, :) = d{x1Cnt, x2Cnt};
  end
end

fTest = zeros(length(x1), length(x2));
for s1Cnt = 1:length(x1)
  for s2Cnt = 1:length(x2)
    sAct = [x1(s1Cnt) x2(s2Cnt)];
    fNow = 0;
    for rowCnt = 1:size(finalPoly, 1)
      pow = 1;
      for parCnt = 1:size(finalPoly, 2)
        pow = pow * sAct(parCnt)^finalPoly(rowCnt, parCnt);
      end
      fNow = fNow + coeffPoly(rowCnt, :) .* pow ;
    end
    fTest(s1Cnt, s2Cnt) = fNow;
  end
end


%%%%%%%%%%%%%%%%%%%%%%%%

t1Low = zeros(length(x2), dimLow);
for j = 1:dimLow
  t1Low(:, j) = evalTscheby(c2Low(:, j), a2, b2, x2);
end
t2Low = zeros(length(x2), length(x1));
for k = 1:size(t1Low, 1)
  t2Low(k, :) = evalTscheby(t1Low(k, :), a1, b1, x1);
end

% plot functions
figure;
surf(x1, x2, t2Low);
figure;
surf(x1, x2, abs(fRes - t2Low));

