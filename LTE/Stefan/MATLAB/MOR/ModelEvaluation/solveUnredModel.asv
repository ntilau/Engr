function fNameSpara = solveUnredModel(modelName, impedanceFlag, ...
  linFreqParamFlag, newFileEndingFlag, saveMatlabFlag, pardisoFlag, tmFlag)


%% load model
tic
disp(' ');
disp('Loading model...');
linearFlag = linFreqParamFlag;

% read "modelParam.txt"
fNameModRedTxt = strcat(modelName, 'modelParam.txt');
[f0, paramNames, paramValInExp, numLeftVecs, abcFlag] = ...
  readModParaTxt(fNameModRedTxt);

numParams = length(paramNames)+1;
c0 = 299792.458e3;
k0 = 2*pi*f0/c0;

% construct matrix with the ordering of the coefficients
permutMat=[];   % first column describes frequency dependence
if linFreqParamFlag
  maxOrder = 1;   % maximum order of parameter dependence
else
  maxOrder = 3;   % maximum order of parameter dependence
end
for k=0:maxOrder
  permutMat = rec(numParams, k, permutMat, 0, 1);
end

% read system matrices
sys0fName = strcat(modelName, 'system matrix');
k2fName = strcat(modelName, 'k^2 matrix');
if newFileEndingFlag
  sys0fName = [sys0fName '.mm'];
  k2fName = [k2fName '.mm'];
end
sys0 = MatrixMarketReader(sys0fName);
k2_mat = MatrixMarketReader(k2fName);
ident = cell(numLeftVecs,1);
for k = 1:numLeftVecs
  if newFileEndingFlag
    fName = [modelName 'ident_' num2str(k-1) '.mm'];
  else
    fName = [modelName 'ident' num2str(k-1)];
  end
  ident{k} = MatrixMarketReader(fName);
end
paramMat = cell(length(paramNames),1);
for k = 1:length(paramNames)
  if newFileEndingFlag
    fName = [modelName paramNames{k} '.mm'];
  else
    fName = strcat(modelName, paramNames{k});
  end
  % names of the material matrices are equal to the parameter names
  paramMat{k} = MatrixMarketReader(fName);
end
toc


%% Build parameter dependend unreduced model
tic
disp(' ')
disp('Building parameter dependend unreduced model...');
% sysMat{1} = [];
sysMat{1} = sys0;

if linFreqParamFlag
  sysMat{2} = -k0^2 * k2_mat;
  % linear material parameter dependences
  for k = 1:length(paramNames)
    row = zeros(1, numParams);  % row describing parameter dependence
    row(k+1) = 1;               % linear parameter dependence
    rowPos = findRowInMat(row,permutMat);
    if strfind(paramNames{k}, 'EPSILON_RELATIVE')
      error(['EPSILON_RELATIVE does not lead to ' ...
        'linear parameter dependence!']);
    elseif strfind(paramNames{k}, 'MU_RELATIVE')
      sysMat{rowPos} = paramMat{k}; %#ok<AGROW>
    else
      error('Unknown material parameter!');
    end
  end
  if abcFlag
    error('ABCs do not lead to linear parameter dependence!');
  end
else
  % linear material parameter dependences
  for k = 1:length(paramNames)
    row = zeros(1, numParams);  % row describing parameter dependence
    row(k+1) = 1;               % linear parameter dependence
    rowPos = findRowInMat(row,permutMat);
    if strfind(paramNames{k}, 'EPSILON_RELATIVE')
      sysMat{rowPos} = -k0^2 * paramMat{k}; %#ok<AGROW>
    elseif strfind(paramNames{k}, 'MU_RELATIVE')
      sysMat{rowPos} = paramMat{k}; %#ok<AGROW>
    else
      error('Unknown material parameter!');
    end
  end
  
  sysMat{2} = -2 * k0^2 * k2_mat;   % linear k dependence
  
  if abcFlag
    fNameABC = [modelName 'ABC'];
    if newFileEndingFlag
      fNameABC = [fNameABC '.mm'];
    end
    abcMat = MatrixMarketReader(fNameABC);
    sysMat{2} = sysMat{2} + abcMat;
  end
  
  % second order dependence:
  sysMat{numParams + 2} = -k0^2 * k2_mat;  % k^2 dependence is -k^2*T
  for k = 1:length(paramNames)
    row = zeros(1, numParams);  % row describing parameter dependence
    row(1) = 1;                 % linear frequency dependence
    row(k+1) = 1;               % linear parameter dependence
    rowPos = findRowInMat(row,permutMat);
    if strfind(paramNames{k}, 'EPSILON_RELATIVE')
      sysMat{rowPos} = -2 * k0^2 * paramMat{k}; %#ok<AGROW>
    end
  end
  
  % third order dependence:
  for k = 1:length(paramNames)
    row = zeros(1, numParams);  % row describing parameter dependence
    row(1) = 2;                 % square frequency dependence
    row(k+1) = 1;               % linear parameter dependence
    rowPos = findRowInMat(row,permutMat);
    if strfind(paramNames{k}, 'EPSILON_RELATIVE')
      sysMat{rowPos} = -k0^2 * paramMat{k}; %#ok<AGROW>
    end
  end
end

rhs = cell(numLeftVecs, 1);
leftVecs = cell(numLeftVecs, 1);
for k = 1:numLeftVecs
  if newFileEndingFlag
    fNameRhs = [modelName 'rhs_' num2str(k-1) '.fvec'];
    fNameLeftVecs = [modelName 'leftVec_' num2str(k-1) '.fvec'];
  else
    fNameRhs = strcat(modelName, 'rhs', num2str(k-1));
    fNameLeftVecs = strcat(modelName, 'leftVec', num2str(k-1));
  end
  rhs{k} = -2 * 1i * vectorReader(fNameRhs);
  leftVecs{k} = vectorReader(fNameLeftVecs);
end

% clear temporary matrices
clear k2_mat;
for k = 1:length(paramNames)
  clear paramMat{k};
end


%% model evaluation

% read "modelParam.txt"
fNameModRedTxt = strcat(modelName, 'modelParam.txt');
[fExp, paramNames, paramValInExp, numLeftVecs, abcFlag] = ...
  readModParaTxt(fNameModRedTxt); %#ok<NASGU>

% read "modelFull.pvar"
fNameModPvar = strcat(modelName, 'modelFull.pvar');
[freqParam, materialParams] = readModParVar(fNameModPvar);

% compute parameter steps of material parameters
for k = 1:length(materialParams)
  if strcmp(materialParams(k).name, 'MU_RELATIVE')
    materialParams(k).steps = calcMuSteps(paramValInExp(k), ...
      materialParams(k).min, materialParams(k).max, ...
      materialParams(k).numPnts);
  elseif strfind(paramNames{k}, 'EPSILON_RELATIVE')
    if linearFlag
      error(['EPSILON_RELATIVE does not lead to ' ...
        'linear parameter dependence!']);
    else
      materialParams(k).steps = calcEpsSteps(paramValInExp(k), ...
        materialParams(k).min, materialParams(k).max, ...
        materialParams(k).numPnts);
    end
  else
    error('Unknown material parameter!');
  end
end

% compute parameter steps of frequency parameter
if linearFlag
  freqParam.steps = calcK_SquareRelSteps(fExp, freqParam.fMin, ...
    freqParam.fMax, freqParam.numPnts);
else
  freqParam.steps = calcRelWaveNumberSteps(fExp, freqParam.fMin, ...
    freqParam.fMax, freqParam.numPnts);
end
scaleRHS = calcScaleRHS(fExp, freqParam.fMin, freqParam.fMax, ...
  freqParam.numPnts, freqParam.fCutOff);
scaleIdent = calcScaleIdent(fExp, freqParam.fMin, freqParam.fMax, ...
  freqParam.numPnts, freqParam.fCutOff);

% warning off all;
% warning off;

pos = 1;
currentStepVals = zeros(length(materialParams), 1);
currentParamVals = zeros(length(materialParams), 1);
if isempty(materialParams)
  stepSpace = [];
  paramSpace = [];
else
  [stepSpace paramSpace] = buildStepSpace(materialParams, pos, [], [], ...
    currentStepVals, currentParamVals);
end
fName = strcat(modelName, 'sysMatRedNames');
if newFileEndingFlag
  fName = [fName '.txt'];
end
sysMatRedNames = readSysMatRedNames(fName);
[r c] = size(sysMatRedNames);

% delete empty matrices from cell array sysMat
nnNonEmpty = 0;
for matCnt = 1 : length(sysMat)
  if ~isempty(sysMat{matCnt})
    nnNonEmpty = nnNonEmpty + 1;
  end
end
sysMatNew = cell(1, nnNonEmpty);
foundNotEmpty = 1;
for matCnt = 1 : length(sysMat)
  if ~isempty(sysMat{matCnt})
    sysMatNew{foundNotEmpty} = sysMat{matCnt};
    foundNotEmpty = foundNotEmpty + 1;
  end
end
clear sysMat;
sysMat = sysMatNew;   % can be made more memory efficient
clear sysMatNew;

toc


%% solve model
disp(' ');
disp('Solving model ...');
tic

[rSpace cSpace] = size(stepSpace);
row = zeros(1, c);
row(1, 1) = 1;
if linearFlag
  % find system matrix with frequency dependence
  posFreq = findRowInMat(row, sysMatRedNames);
else
  % find system matrix with linear k dependence
  posLinK = findRowInMat(row, sysMatRedNames);
  row(1, 1) = 2;
  % find system matrix with square k dependence
  posSquK = findRowInMat(row, sysMatRedNames);
end

sMat = cell(freqParam.numPnts, 1);
redRhsScaled = cell(numLeftVecs,1);
for kStepCnt = 1:freqParam.numPnts
  if linearFlag
    fMat = sysMat{1} + freqParam.steps(kStepCnt) * sysMat{posFreq};
  else
    fMat = sysMat{1} + freqParam.steps(kStepCnt)*sysMat{posLinK} + ...
      freqParam.steps(kStepCnt)^2*sysMat{posSquK};
  end
  if ~impedanceFlag
    for excitationCnt = 1:numLeftVecs
      fMat = fMat + scaleIdent{excitationCnt}(kStepCnt) ...
        * ident{excitationCnt};
    end
  end
  for k = 1:numLeftVecs
    % rhs is only frequency dependent
    if impedanceFlag
      redRhsScaled{k} = -0.5*scaleRHS{k}(kStepCnt)*rhs{k};
    else
      redRhsScaled{k} = scaleRHS{k}(kStepCnt)*rhs{k};
    end
  end
  if cSpace
    for pntCnt = 1:cSpace
      currentMat = fMat;
      for sysMatCnt = 1:length(sysMat)
        if sysMatRedNames(sysMatCnt, 2:end) == ...
            zeros(1, length(materialParams))
          % do nothing, only pure frequency dependence,
          % which is already considered
        else
          scale = 1;
          % frequency dependence
          scale = scale * ...
            (freqParam.steps(kStepCnt))^sysMatRedNames(sysMatCnt,1);
          % material dependence
          if length(sysMatRedNames(sysMatCnt,:)) > 1
            for pCnt = 2:length(sysMatRedNames(sysMatCnt,:))
              scale = scale * stepSpace(pCnt-1,pntCnt) ...
                ^sysMatRedNames(sysMatCnt,pCnt);
            end
          end
          % add matrices to build system matrix
          % in current point in parameter space
          currentMat = currentMat + scale * sysMat{sysMatCnt};
        end
      end
      % solve system
      if pardisoFlag
        % determine matrix type
        if nnz(imag(currentMat))
          mtype = 6;  % complex symmetric indefinite matrix
        else
          mtype = -2;  % real symmetric indefinite matrix
        end
        % Fill-reduction analysis and symbolic factorization
        [iparm pt err A_val A_ia A_ja ncol] = ...
          pardisoReorderLTE(mtype, currentMat);
        % Numerical factorization
        err = pardisoFactorLTE(mtype, iparm, pt, A_val, ...
          A_ia, A_ja, ncol);
        if err ~= 0
          error(['Pardiso error during factorization: ' err]);
        end
        for rhsCnt = 1:length(redRhsScaled)
          % Forward and Backward solve
          [sol err] = pardisoSolveLTE(mtype, iparm, pt, ...
            A_val, A_ia, A_ja, ncol, redRhsScaled{rhsCnt}, 0);
          if err ~= 0
            error(['Pardiso error during solving: ' err]);
          end
          for lVecCnt = 1:numLeftVecs
            sMat{(kStepCnt-1)*cSpace + pntCnt}(lVecCnt,rhsCnt) = ...
              leftVecs{lVecCnt}.' * sol;
          end
        end
        err = pardisoReleaseMemory(mtype,iparm,pt,A_val,A_ia,A_ja,ncol);
        if err ~= 0
          error(['Pardiso error during memory release: ' err]);
        end
      else
        [L, U, P, Q] = lu(currentMat);
        for rhsCnt = 1:length(redRhsScaled)
          sol = Q * (U \ (L \ (P * redRhsScaled{rhsCnt})));
          for lVecCnt = 1:numLeftVecs
            sMat{(kStepCnt-1)*cSpace + pntCnt}(lVecCnt,rhsCnt) = ...
              leftVecs{lVecCnt}.' * sol;
          end
        end
      end
    end
  else  % no material dependence, only pure frequency dependence
    % solve system
    if pardisoFlag
      % determine matrix type
      if nnz(imag(fMat))
        mtype = 6;  % complex symmetric indefinite matrix
      else
        mtype = -2;  % real symmetric indefinite matrix
      end
      % Fill-reduction analysis and symbolic factorization
      [iparm pt err A_val A_ia A_ja ncol] = ...
        pardisoReorderLTE(mtype, fMat);
      % Numerical factorization
      err = pardisoFactorLTE(mtype, iparm, pt, A_val, ...
        A_ia, A_ja, ncol);
      if err ~= 0
        error(['Pardiso error during factorization: ' err]);
      end
      for rhsCnt = 1:length(redRhsScaled)
        % Forward and Backward solve
        [sol err] = pardisoSolveLTE(mtype, iparm, pt, ...
          A_val, A_ia, A_ja, ncol, redRhsScaled{rhsCnt}, 0);
        if err ~= 0
          error(['Pardiso error during solving: ' err]);
        end
        for lVecCnt = 1:numLeftVecs
          sMat{kStepCnt}(lVecCnt, rhsCnt) = leftVecs{lVecCnt}.' * sol;
        end
      end
      err = pardisoReleaseMemory(mtype,iparm,pt,A_val,A_ia, A_ja, ncol);
      if err ~= 0
        error(['Pardiso error during memory release: ' err]);
      end
    else
      [L, U, P, Q] = lu(fMat);
      for rhsCnt = 1:length(redRhsScaled)
        sol = Q * (U \ (L \ (P * redRhsScaled{rhsCnt})));
        for lVecCnt = 1:numLeftVecs
          sMat{kStepCnt}(lVecCnt, rhsCnt) = leftVecs{lVecCnt}.' * sol;
        end
      end
    end
  end
end

if impedanceFlag
  % sMat is really an impedance matrix
  % compute scattering matrix from the impedance matrix
  for sMatCnt = 1:length(sMat)
    sMat{sMatCnt} = (sMat{sMatCnt} - eye(numLeftVecs)) ...
      \ (sMat{sMatCnt} + eye(numLeftVecs));
  end
else
  % subtract excitation
  for k = 1:length(sMat)
    [r c] = size(sMat{k});
    sMat{k} = sMat{k} - eye(r, c);
  end
end

toc

%% Save results
disp(' ');
disp('Saving results ...');
tic

fNameSpara = strcat(modelName, 'S_f_', num2str(freqParam.fMin,'%14.14g'), ...
  '_', num2str(freqParam.fMax,'%14.14g'), '_', ...
  num2str(freqParam.numPnts,'%14.14g'));
for k = 1:length(paramNames)
  fNameSpara = strcat(fNameSpara, '_', paramNames{k}, '_', ...
    num2str(materialParams(k).min,'%14.14g'), '_', ...
    num2str(materialParams(k).max,'%14.14g'), '_', ...
    num2str(materialParams(k).numPnts,'%14.14g'));
end

if saveMatlabFlag
  fNameSpara = [fNameSpara, '_full.mat'];
  save(fNameSpara, 'sMat', 'freqParam', 'materialParams', 'numLeftVecs', ...
    'paramSpace', 'paramNames');
else
  fNameSpara = [fNameSpara, '_full.txt'];
  saveSmatrix(sMat, freqParam, materialParams, fNameSpara, numLeftVecs, ...
    paramSpace, paramNames);
end

toc
