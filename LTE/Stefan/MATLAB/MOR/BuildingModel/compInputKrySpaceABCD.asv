function K = compInputKrySpaceABCD(Model, Fact, order, orthoFlag, pardisoFlag)


numParams = size(Model.permutMat,2);
% find out dimension of B block vectors
for k = 1:length(Model.B)
  if ~isempty(Model.B{k})
    colsB = size(Model.B{k},2);
    break;
  end
end

interpolPnts = calcInterpolPnts(numParams, order);
numVectorsTotal = 0;
for orderCnt = 0:order
  numInterpolPntsOrder = nchoosek(orderCnt+numParams-1, orderCnt);
  numVectorsTotal = numVectorsTotal + numInterpolPntsOrder;
end
numVectorsTotal = numVectorsTotal * colsB;
% compute input Krylov space
K = zeros(size(Model.A{1},1), numVectorsTotal);
normNewDirection = zeros(1, numVectorsTotal);
currentCol = 0;



sol = cell(size(Model.B,2);
for k = 1:size(Model.B,2)
  sol{k} = Fact.Q*(Fact.U\(Fact.L\(Fact.P*Model.B(:,k))));
end



for iKrySpace = 1:colsB
  for orderCnt = 1:length(interpolPnts)
    for pntCnt = 1:size(interpolPnts{orderCnt}, 1);
      oneParamModel = createOneParamModel(Model.A, Model.permutMat, ...
        interpolPnts{orderCnt}(pntCnt,:));
      rhs = cell(length(Model.B),1);
      for m = 1:length(Model.B)
        if ~isempty(Model.B{m})
          rhs{m} = Model.B{m}(:,iKrySpace);
        end
      end
%       [Q] = wcaweImprvdCirc(Fact, oneParamModel, order, [], [], orthoFlag, ...
%         pardisoFlag, rhs);
      [Q] = wcaweImprvd(Fact, oneParamModel, ...
        sol{iKrySpace}, order, [], [], orthoFlag, ...
        pardisoFlag);
      if ~nnz(K)
        K(:,1:size(Q,2)) = Q;
        currentCol = size(Q,2);
      else
        for colCnt = 1:size(Q,2)
          if colCnt >= orderCnt
            v = Q(:,colCnt);
            [v projCoeffs] = orthoAgainstSpace(v, K, currentCol, orthoFlag);
            currentCol = currentCol + 1;
            normNewDirection(currentCol) = projCoeffs(currentCol);
            K(:,currentCol) = v;
          end
        end
      end
    end
  end
end


